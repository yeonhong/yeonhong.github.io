---
layout: single
title: "On DOTS: C++ & C#"
categories: 
  - 프로그래밍
tags:
  - Unity
  - 멀티스레드
---

[출처](https://blogs.unity3d.com/kr/2019/02/26/on-dots-c-c/)

## Introduce

> 이것은 우리의 새로운 [Data-Oriented Tech Stack (DOTS)](https://unity.com/dots)에 대한 간략한 소개로, 우리가 현재 어디에 있고 어떻게 그리고 왜 왔는지, 그리고 우리가 다음에 어디로 갈지에 대한 통찰력을 공유합니다. 우리는 가까운 미래에 이 블로그에 DOTS에 대한 자세한 내용을 게시 할 계획 입니다.

하루가 끝나면 많은 고급 게임 프로그래머의 문제 중 하나는 대상 프로세서가 이해할 수있는 지침을 실행 파일에 제공해야하며 실행될 때 게임이 실행될 수 있어야한다는 것입니다.

우리 코드의 성능에 중대한 부분을 위해, 우리는 최종 지침이 무엇을 원하는지 알고 있습니다. 우리는 논리를 합리적인 방법으로 설명하기 쉬운 방법을 원하고, 생성된 명령이 우리가 원하는 명령임을 신뢰하고 검증합니다.

우리의 견해로 C ++은이 작업에서별로 좋지 않습니다. 내 루프가 벡터화되기를 원하지만, 컴파일러가 벡터화하지 않을 수있는 수많은 일이 발생할 수 있습니다. 오늘은 벡터화 될 수 있지만, 겉보기에 무고한 새로운 변화가 일어나면 내일은 그렇지 않습니다. 모든 C / C ++ 컴파일러가 내 코드를 벡터화하는 것을 어렵지 않게 만드는 것은 어렵습니다.

우리는 우리가 신경 쓰는 모든 상자를 검사하는 "기계 코드를 생성하는 비교적 합리적인 방법"을 만들기로 결정했습니다. 우리는 C ++ 디자인 기차를 약간 더 잘 작동시키는 방향으로 조금 더 구부리기 위해 많은 에너지를 소비 할 수있었습니다. 그러나 우리는 모든 것을 할 수있는 툴체인에 그 에너지를 소비하는 편이 낫습니다. 게임 개발자가 가지고있는 문제에 대해 정확히 설계하는 것입니다.

우리가 생각하는 체크 박스는 무엇입니까?

* 성능은 정확성입니다. 나는 "어떤 이유로 든이 루프가 벡터화되지 않으면 컴파일러 오류가 발생합니다. '오 코드는 이제 8 배 느리지 만 여전히 정확한 값을 생성합니다.!"라고 말할 수 있어야합니다. '"
* 교차 아키텍처. 내가 작성한 입력 코드는 Xbox를 대상으로하는 것과 iOS를 대상으로 할 때 다를 필요는 없습니다.
* 우리는 코드를 변경하면서 모든 아키텍처에 대해 생성 된 기계 코드를 쉽게 볼 수있는 멋진 반복 루프를 만들어야합니다. 기계 코드 "뷰어"는 이러한 모든 기계 명령어가 수행하는 것을 가르치거나 설명 할 때 훌륭한 작업을 수행해야합니다.
* 안정성. 대부분의 게임 개발자는 우선 순위 목록에서 높은 안정성을 갖고 있지는 않지만, Unity에서 메모리 손상이 발생하기가 정말로 어렵다는 사실이 그 중요한 기능 중 하나라고 생각합니다. 경계를 읽거나 쓸어 버리거나 null을 역 참조하는 경우 중대한 오류 메시지와 함께 명확한 오류를 줄 수 있는 이 코드를 실행할 수 있는 모드가 있어야합니다.

자, 우리가 신경 쓰는 것이 무엇인지 알았으니 다음 단계는이 기계 코드 생성기의 입력 언어가 무엇인지 결정하는 것입니다. 다음과 같은 옵션이 있다고 가정 해 보겠습니다.

* Custom language
* Some adaption/subset of C or C++
* Subset of C#

왜 C#을? 가장 중요한 성능의 내부 루프를? 예. C#은 Unity에 많은 장점을 제공하는 매우 자연스러운 선택입니다.

* 사용자가 이미 사용하고있는 언어입니다.
* 디버깅뿐만 아니라 편집 / 리팩토링도 훌륭한 IDE 도구입니다.
* C# -> 중간 IL 컴파일러가 이미 존재합니다. (Microsoft의 Roslyn C# 컴파일러), 우리는 직접 작성해야하는 대신 사용할 수 있습니다.
* 우리는 중간 IL을 수정 한 경험이 많기 때문에 실제 프로그램에서 코드gen 및 후 처리 작업을 쉽게 수행 할 수 있습니다.
* 많은 C++ 문제 (헤더 포함 지옥, PIMPL 패턴, 긴 컴파일 시간)를 피합니다.

나는 C#으로 직접 코드를 작성하는 것을 즐긴다. 그러나 전통적인 C#은 성능면에서 놀라운 언어는 아닙니다. C# 언어 팀, 표준 라이브러리 팀 및 런타임 팀은 지난 2 년 동안 큰 발전을 이루었습니다. **C# 언어를 사용하면 데이터가 메모리에 배치되는 위치와 방법을 제어 할 수 없습니다. 이것이 바로 성과를 향상시키는 데 필요한 것입니다.**

그 외에, 표준 라이브러리는 "힙에 있는 오브젝트"와 "다른 오브젝트에 대한 참조 포인터가 있는 오브젝트"를 중심으로합니다.

즉 성능이 중요한 코드를 작업 할 때 우리는 표준 라이브러리 (bye Linq, StringFormatter, List, Dictionary)의 대부분을 포기하고 할당을 허용하지 않고 (= 클래스가없고 struct 만), 리플렉션, GC 및 Virtual Call을 사용할 수 있으며 몇 가지 새 컨테이너를 추가 할 수 있습니다 (NativeArray 및 친구). 그런 다음 C # 언어의 나머지 부분은 정말 좋아 보인다. [Aras의 블로그](http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/)에서 [경로 추적기 장난감 프로젝트](https://github.com/aras-p/ToyPathTracer)의 몇 가지 예를 확인하십시오.

이 Subset 는 핫 루프에서 필요한 모든 것을 편안하게 해줍니다. C #의 유효한 하위 집합이기 때문에 일반 C #으로도 실행할 수 있습니다. 우리는 C ++에서 작업 할 때, 잊어 버린 오류 메시지, 디버거 지원 및 컴파일 속도와 함께 범위를 벗어난 액세스에서 오류를 얻을 수 있습니다. 우리는 종종이 하위 집합을 High-Performance C# 또는 HPC#라고 부릅니다.

## Burst compiler: Where are we today?

우리는 Burst라고 불리는 코드 생성기 / 컴파일러를 만들었습니다. Unity 2018.1 이후에 미리보기 패키지로 제공되었습니다. 우리는 앞으로 많은 일을해야하지만, 우리는 이미 그 일에 이미 만족하고 있습니다.

때때로 C ++보다 빠르며 C ++보다 느린 경우도 있습니다. 후자의 경우 우리는 우리가 해결할 수 있다고 확신하는 성능 버그 입니다.

단지 성능 비교만으로는 충분하지 않습니다. 동등하게 중요한 점은 당신이 그 성과를 얻으려면 무엇을해야만하는지입니다. 
> 예 : 현재 C++ 렌더러의 C++ 컬링 코드를 가져 와서 버스트로 포팅했습니다. 성능은 같았지만 C++ 버전은 우리의 C++ 컴파일러가 실제로 벡터화되도록 설득하기 위해 엄청난 작업을 해야했습니다. 버스트 버전은 약 4배 작았습니다.

솔직하게 말해서, "가장 중요한 성능 코드를 C #으로 옮겨야합니다"라는 이야기는 Unity가 내부적으로 모든 사람이 즉시 도입하라고 하는것은 아닙니다. 우리 대부분은 C++을 사용할 때 "당신은 금속에 가깝습니다"라고 느낍니다. 그러나 그것은 더이상 사실이 아닐 것입니다. 우리가 C#을 사용할 때 소스 컴파일에서 기계 코드 생성에 이르기까지 전체 프로세스를 완벽하게 제어 할 수 있습니다. 우리가 마음에 들지 않는 것이 있으면 그냥 들어가서 고칠 수 있습니다.

우리는 천천히 그러나 확실하게 우리가 C ++에서 가지고있는 모든 중요한 성능 코드를 HPC #로 이식 할 것입니다. 우리가 원하는 성능을 얻고, 버그를 작성하기가 쉽고, 작업하기가 더 쉽습니다.

Burst Inspector의 스크린 샷을 통해 서로 다른 버스트 핫 루프에 대해 생성 된 어셈블리 지침을 쉽게 볼 수 있습니다.

![no-alignment](https://blogs.unity3d.com/wp-content/uploads/2019/02/burst-inspector.png)

Unity에는 많은 사용자가 있습니다. 일부는 메모리에서 전체 arm64 명령어 세트를 열거 할 수 있으며 컴퓨터 과학 분야에서 박사 학위를 취득하지 않고도 다른 것들을 만들 수 있습니다.

모든 사용자는 엔진 코드 (일반적으로 90 % 이상)를 소비하는 데 소요되는 프레임 시간의 일부로 이익을 얻습니다. Asset Store 패키지 작성자가 HPC#을 채택 할 때 Asset Store 패키지 런타임 코드를 실행하는 부분이 더 빨라집니다.

고급 사용자는 HPC#에 고유 한 고성능 코드를 작성할 수도 있기 때문에 고급 기능을 활용할 수 있습니다.

## Optimization granularity (세분화된 최적화)

C ++에서는 컴파일러에게 프로젝트의 다른 부분에 대해 서로 다른 최적화 절충을 요구하는 것은 매우 어렵습니다. 최적화 수준 지정시 파일 세분성이 가장 좋습니다.

Burst는 해당 프로그램에서 입력으로 단일 메서드를 사용하도록 설계되었습니다. 핫 루프의 진입 점입니다. 이 함수와 그 함수가 호출하는 모든 것을 컴파일 할 것입니다 (우리는 가상 함수 나 함수 포인터를 허용하지 않습니다).

버스트는 프로그램의 비교적 작은 부분에서만 작동하기 때문에 최적화 수준을 11로 설정합니다. 버스트 인라인은 거의 모든 호출 쪽에서 발생합니다. 인라인 된 양식에서 함수의 인수에 대한 자세한 정보가 있기 때문에 그렇지 않으면 제거되지 않는 검사를 제거하십시오.

## How that helps with common multithreading problems (일반적인 멀티 스레딩 문제를 어떻게 해결하는가?)

C++ (또는 C#)은 개발자가 스레드-보호 코드를 작성하는 것을 돕지 않습니다.

게임 소비자 하드웨어의 코어가 1을 넘은 지 10년이 넘은 오늘날에도 여러 코어를 효과적으로 사용하는 프로그램을 출시하는 것은 매우 어렵습니다.

데이터 경주, 비결정주의 및 교착 상태는 다중 스레드 코드를 쉽게 전달할 수없는 문제입니다. 우리가 원하는 것은 "이 함수와 그것이 호출하는 모든 것이 결코 전역 상태를 읽거나 쓰지 못하게하는 것"과 같은 기능입니다. 우리는 규칙 위반이 컴파일러 오류가 아니라 "모든 프로그래머가 준수하기를 희망하는 지침"이되기를 바랍니다. 버스트가 컴파일러 오류를 발생시킵니다.

우리는 Unity 사용자와 우리 모두에게 일자리를 창출해야하는 모든 데이터 변환을 분할하는 "실용적인"코드 작성을 권장합니다. 각 작업은 부작용이없는 것처럼 "기능적"입니다. **읽기 전용 버퍼와이 버퍼가 작동하는 읽기/쓰기 버퍼를 명시적으로 지정합니다. 다른 데이터에 액세스하려고하면 컴파일러 오류가 발생합니다.**

작업 스케줄러는 작업이 실행되는 동안 아무도 당신의 읽기 전용 버퍼에 쓰지 못하도록 보장합니다. 또한 작업이 실행되는 동안 아무도 읽기/쓰기 버퍼에서 읽지 못하도록 보장합니다.

이러한 규칙을 위반하는 작업을 예약하면 매번 런타임 오류가 발생합니다. 운이 좋지 않은 경쟁 상황에서만 그렇지 않습니다. 이 오류 메시지는 버퍼 A에서 읽으려는 작업을 예약하려고하지만 A에 쓰여기 전에 이미 작업을 예약했음을 설명합니다. 이렇게하려면 이전 작업을 지정해야합니다 종속성으로서의 일.

우리는 이러한 안전 메커니즘이 커밋되기 전에 많은 버그를 잡아 내고 모든 코어를 효율적으로 사용하게된다는 것을 알게되었습니다. 교착 상태 또는 경쟁 조건을 코딩하는 것을 어렵게합니다. 결과는 실행중인 스레드의 수 또는 스레드가 다른 프로세스에 의해 인터럽트 된 시간과 관계없이 결정적으로 보장됩니다.

## Hacking the whole stack

이러한 모든 구성 요소를 해킹 할 수 있으므로 서로 인식 할 수 있습니다. 예를 들어 벡터화가 발생하지 않는 일반적인 경우는 컴파일러가 두 포인터가 동일한 메모리 (별칭 지정)를 가리 키지 않는다고 보장 할 수 없다는 것입니다. 우리는 컬렉션 라이브러리를 작성했기 때문에 두 개의 NativeArray가 별칭을 사용하지 않을 것이라고 알고 있습니다. 따라서 버스트에서이 지식을 사용할 수 있으므로 두 개의 배열 포인터가 동일한 메모리를 가리킬 수도 있으므로 최적화를 포기할 필요가 없습니다.

마찬가지로 우리는 Unity.Mathemetics 수학 라이브러리를 작성했습니다. 버스트는 그것에 대해 잘 알고 있습니다. math.sin ()과 같은 것들에 대한 정확도를 희생시키는 것이 (미래에) 가능할 것입니다. Burst math.sin ()은 컴파일 할 C# 메소드가 아니기 때문에 sin ()의 삼각 함수를 이해하고 x의 작은 값에 대해 sin (x) == x를 이해합니다 (Burst가 증명할 수 있음). ), 특정 정확도 희생을 위한 테일러 급수 확장으로 대체 될 수 있음을 이해합니다. 크로스 플랫폼 및 아키텍처 부동 소수점 결정론은 우리가 달성 할 수 있다고 믿는 미래의 버스트 목표입니다.

## The distinction between engine code and game code disappears (엔진 코드와 게임 코드의 구분이 사라지다.)

Unity의 런타임 코드를 HPC #에 쓰면 엔진과 게임이 같은 언어로 작성됩니다. 우리는 HPC #로 변환 한 런타임 시스템을 소스 코드로 배포 할 것입니다. 누구나 그들에게서 배울 수 있고, 그것을 향상시키고, 그들을 맞출 수 있습니다. 우리는 우리가 쓰는 것보다 더 나은 파티클 시스템, 물리 시스템 또는 렌더러를 쓰지 못하도록하는 수준의 경기장을 갖출 것입니다. 많은 사람들이 기대합니다. 내부 개발 프로세스를 사용자의 개발 프로세스와 훨씬 비슷하게 만들면 사용자가 더 직접적으로 고통을 느낄 수 있으며 두 가지 작업 대신 단일 워크 플로를 개선하는 데 모든 노력을 집중할 수 있습니다.