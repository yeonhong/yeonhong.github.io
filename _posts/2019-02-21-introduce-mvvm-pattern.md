---
layout: single
title: "MVVM Pattern"
categories: 
  - 프로그래밍
tags:
  - Design Pattern
  - MVVM
link: https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246(v=pandp.10)
---

## 소개
MVVM 패턴은 Silverlight와 같은 XAML 응용 프로그램 플랫폼에 자연스럽게 적합합니다. 이는 MVVM 패턴이 데이터 바인딩, 명령 및 동작과 같은 Silverlight의 특정 기능을 활용하기 때문입니다. MVVM은 UI의 모양과 레이아웃에 대한 책임을 표현 논리에 대한 책임과 분리하는 많은 다른 패턴과 유사합니다. 예를 들어 MVC (Model-View-Controller) 패턴에 익숙하다면 MVVM에는 많은 유사한 개념이 있다는 것을 알 수 있습니다.

## Motivation for the MVVM Pattern
Windows Forms, WPF, Silverlight 및 Windows Phone과 같은 개발 기술은 개발자가 컨트롤을 도구 상자에서 디자인 화면으로 드래그 한 다음 양식의 코드 숨김 파일에 코드를 작성하는 기본 경험을 제공합니다. 이러한 응용 프로그램의 규모와 범위가 확대되고 수정됨에 따라 복잡한 유지 관리 문제가 발생하기 시작합니다. 이러한 문제에는 UI 컨트롤과 비즈니스 로직 간의 긴밀한 결합이 포함되어 UI 수정 비용 및 이러한 코드의 단위 테스트 어려움이 증가합니다.

MVVM 패턴을 사용하여 응용 프로그램을 구현하는 주요 동기는 다음과 같습니다.
1. 그것은 관심(concerns)의 분리를 제공합니다. 밀접하게 결합되고 변화가 심한 코드는 모든 종류의 장기 유지 관리 문제를 야기하며 궁극적으로는 제공되는 소프트웨어에 대한 고객 만족도가 떨어집니다. 애플리케이션 로직과 UI를 명확하게 구분하면 애플리케이션을 테스트, 유지 및 발전시키는 것이 더 쉬워집니다. 코드 재사용 기회를 개선하고 개발자 - 디자이너 워크 플로우를 지원합니다.
2. XAML 플랫폼에 대한 자연스러운 패턴입니다. MVVM 패턴의 핵심 요소는 Silverlight 플랫폼의 풍부한 데이터 바인딩 스택과 종속성 속성입니다. 이들의 조합은 UI를 뷰-모델에 연결하는 수단을 제공합니다.
3. 개발자 - 디자이너 워크 플로우가 가능합니다. UI XAML이 코드 숨김과 밀접하게 결합되어 있지 않으면 디자이너가 창의적이고 훌륭한 제품을 만드는 데 필요한 자유를 쉽게 행사할 수 있습니다.
4. 애플리케이션 테스트 가능성을 높입니다. UI 기술을 독립적으로 인스턴스화 할 수있는 별도의 클래스로 UI 로직을 이동하면 유닛 테스트가 훨씬 쉬워집니다.

> 즉, ui디자인과 개발자코드의 결합도 분리를 위한것.

## The MVVM Pattern
Model-View-ViewModel 패턴은 모든 XAML 플랫폼에서 사용할 수 있습니다. 이 인터페이스의 목적은 사용자 인터페이스 컨트롤과 해당 로직 간의 명확한 분리를 제공하는 것입니다.

MVVM 패턴에는 Model, View, View Model의 세 가지 핵심 구성 요소가 있습니다. 각각은 별개의 역할을 수행합니다. 다음 그림은 세 가지 구성 요소 간의 관계를 보여줍니다.

![no-alignment](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/images/hh830877.1afe20bab0052f5ab0fc400bf3b6f3f7%28en-us%2cpandp.10%29.png)

![no-alignment](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/images/gg405484.333d7f906287fb8887d43c85a4a8fc08%28en-us%2cpandp.40%29.png)

구성 요소는 서로 분리되어 다음을 가능하게합니다.

* swap될 components
* 다른 사람에게 영향을주지 않고 변경가능한 내부 구현
* 독립적으로 작업이 되는 구성 요소
* 격리된 단위 테스트

세 가지 구성 요소의 책임을 이해하는 것 외에도 구성 요소가 서로 어떻게 상호 작용하는지 이해하는 것도 중요합니다. 최상위 레벨에서 뷰는 뷰-모델을 **"인식"**하고 뷰-모델은 모델을 **"알 수만 있고,"** 모델은 뷰-모델을 **인식하지 못하고**뷰-모델은 뷰를 **인식하지 못합니다.**

뷰 모델은 뷰를 모델 클래스에서 분리하고 모델이 뷰와 독립적으로 전개되도록합니다.

### View

뷰는 사용자가 화면에서 보는 구조, 레이아웃 및 모양을 정의하는 역할을합니다. 이상적으로 뷰는 비즈니스 로직을 포함하지 않는 제한된 코드 숨김으로 XAML로만 정의됩니다.

Windows Phone 응용 프로그램에서 뷰는 일반적으로 응용 프로그램의 페이지입니다. 또한 뷰는 상위 뷰의 하위 구성 요소이거나 ItemsControl의 개체에 대한 DataTemplate이 될 수 있습니다.

뷰는 자체 뷰-모델을 가질 수도 있고 부모 뷰-모델을 상속받을 수도 있습니다. 뷰는 **바인딩**을 통해 뷰-모델에서 데이터를 가져 오거나 뷰-모델에서 메소드를 호출합니다. 런타임에 UI 컨트롤이 변경 알림 이벤트를 발생시키는 뷰-모델 속성에 응답하면 뷰가 변경됩니다.

뷰의 상호 작용 (예 : 버튼 클릭 또는 항목 선택)에 대한 응답으로 뷰 모델에서 코드를 실행하기위한 몇 가지 옵션이 있습니다. 컨트롤이 명령 소스 인 경우 컨트롤의 Command 속성은 뷰 모델의 ICommand 속성에 데이터 바인딩 될 수 있습니다. 컨트롤의 명령이 호출되면 뷰 모델의 코드가 실행됩니다. 명령 외에도 동작을 뷰의 개체에 연결할 수 있으며 호출 할 명령이나 발생시킬 이벤트를 수신 할 수 있습니다. 이에 대한 응답으로 동작은 뷰 모델에서 ICommand를 호출하거나 뷰 모델에서 메서드를 호출 할 수 있습니다.

### Model

MVVM의 모델은 비즈니스 및 유효성 검사 논리와 함께 데이터 모델을 포함하는 응용 프로그램의 도메인 모델을 구현 한 것입니다. 모델 개체의 예로는 리포지토리, 비즈니스 개체, DTO (Data Transfer Object), POCO (Plain Old CLR Objects) 및 생성 된 엔터티 및 프록시 개체가 있습니다.

### View Model

뷰 모델은 뷰와 모델 사이의 중개자 역할을하며 뷰의 로직을 처리합니다. 

일반적으로 뷰 모델은 모델 클래스에서 메소드를 호출하여 모델과 상호 작용합니다. 그런 다음보기 모델은 뷰에서 쉽게 사용할 수있는 양식으로 모델의 데이터를 제공합니다. 뷰 모델은 모델에서 데이터를 검색 한 다음 뷰에서 데이터를 사용할 수있게 만들고 뷰를보다 쉽게 처리 할 수 있도록 데이터를 다시 포장 할 수 있습니다. 

뷰 모델은 또한 애플리케이션 사용자가 뷰에서 시작하는 명령의 구현을 제공합니다. 예를 들어, 사용자가 UI에서 버튼을 클릭하면 해당 동작이 뷰 모델에서 명령을 트리거 할 수 있습니다. 뷰 모델은 또한 일부 조작이 보류 중임을 나타내는 표시와 같이 뷰에서 디스플레이의 일부 측면에 영향을주는 논리 상태 변경을 정의 할 책임이 있습니다.

뷰 모델이 뷰와의 양방향 데이터 바인딩에 참여하려면 해당 property가 PropertyChanged 이벤트를 발생시켜야합니다.

뷰 모델은 INotifyPropertyChanged 인터페이스를 구현하고 속성이 변경 될 때 PropertyChanged 이벤트를 발생시켜이 요구 사항을 충족시킵니다. 리스너는 속성 변화가 발생할 때 적절하게 대응할 수 있습니다.

컬렉션의 경우보기 쉽도록 System.Collections.ObjectModel.ObservableCollection <T>이 제공됩니다. 이 컬렉션은 컬렉션 변경 알림을 구현하여 개발자가 컬렉션에서 INotifyCollectionChanged 인터페이스를 구현하지 않아도되게 합니다.

### Connecting View Models to Views

MVVM은 Silverlight의 데이터 바인딩 기능을 활용하여 비헤이비어 및 이벤트 트리거와 함께 뷰 및 뷰 모델 간 링크를 관리합니다. 이러한 기능으로 인해 뷰의 코드 숨김에 비즈니스 로직을 배치 할 필요가 없습니다.

직접 관계 및 컨테이너 기반 접근법을 포함하여 뷰 모델을 뷰에 연결하는 데는 여러 가지 방법이 있습니다. 그러나 모든 뷰는 DataContext 속성에 할당 된 뷰 모델을 가지는 것과 동일한 목표를 공유합니다.

뷰는 code-behind file 또는 뷰 자체에서 뷰 모델에 연결할 수 있습니다.

#### code-behind

뷰에는 code-behind 파일에 코드가 있어 뷰 모델이 DataContext 속성으로 할당됩니다. 이는 새로운 뷰 모델을 인스턴스화 하고 이를 DataContext에 할당하는 뷰, 또는 inversion-of-control 컨테이너를 사용하여 뷰 모델을 뷰에 삽입하는 뷰일 수 있습니다.

그러나 뷰 모델을 코드 숨김 파일의 뷰에 연결하는 것은 Visual Studio 및 Microsoft Expression Blend® 디자인 소프트웨어에서 디자이너에게 문제를 일으킬 수 있으므로 권장하지 않습니다.

> 그냥 뷰와 뷰-모델을 연결하도록 하자.. (인터페이스로)

#### View

뷰 모델에 생성자 인수가 없으면 뷰 모델을 뷰의 DataContext로 인스턴스화 할 수 있습니다. 

이 작업을 수행하는 일반적인 방법은 뷰 모델 검색 기능을 사용하는 것입니다. 이것은 개별 뷰가 데이터를 바인딩 할 수있는 속성으로 애플리케이션의 뷰 모델을 노출하는 리소스입니다. 

이 접근법은 응용 프로그램이 뷰 모델을 뷰에 연결하는 단일 클래스를 가짐을 의미합니다. 또한 개발자는 뷰 모델 검색기 내에서 수동으로 연결을 선택하거나 종속성 주입 컨테이너(DI)를 사용하여 자유롭게 선택할 수 있습니다.

## The Benefits of MVVM

MVVM은 훌륭한 개발자 - 디자이너 워크 플로우를 제공하여 다음과 같은 이점을 제공합니다.

* 개발 프로세스 중에 개발자와 설계자는 자신의 구성 요소에 대해보다 독립적으로 동시에 작업 할 수 있습니다. 디자이너는보기에 집중할 수 있으며 Expression Blend를 사용하는 경우 개발자는 작업 할 샘플 데이터를 쉽게 생성 할 수 있으며 개발자는 뷰-모델 및 모델 구성 요소를 작업 할 수 있습니다.
* 개발자는 뷰를 사용하지 않고 뷰 모델 및 모델에 대한 단위 테스트를 만들 수 있습니다. 뷰 모델에 대한 단위 테스트는 뷰에서 사용한 것과 동일한 기능을 수행 할 수 있습니다.
* 보기가 XAML로 완전히 구현되기 때문에 코드를 건드리지 않고도 응용 프로그램의 UI를 쉽게 다시 디자인 할 수 있습니다. 뷰의 새 버전은 기존 뷰 모델과 함께 작동해야합니다.
* 기존 비즈니스 로직을 캡슐화하는 모델의 기존 구현이있는 경우 변경하기가 어려울 수도 위험 할 수도 있습니다. 이 시나리오에서 뷰 모델은 모델 클래스의 어댑터 역할을하므로 모델 코드를 크게 변경하지 않아도됩니다.

MVVM에 대한 자세한 내용은 Prism 설명서에서 [5 장, MVVM 패턴 구현](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/gg405484%28v%3dpandp.40%29) 및 [6 장, 고급 MVVM 시나리오](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/gg405494%28v%3dpandp.40%29)를 참조하십시오.